package com.naveen.example.ssologin.data;

import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Set;

import org.apache.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.naveen.example.ssologin.model.AuthorizationDecision;
import com.naveen.example.ssologin.model.NewPolicy;
import com.naveen.example.ssologin.model.UserInfo;
import com.naveen.example.ssologin.utility.EncryptionDecryptionUtility;
import com.naveen.example.ssologin.utility.StringToNumberConversion;

@Service
public class AuthorizationDaoImpl {

	@Autowired
	EncryptionDecryptionUtility encryptionDecryptionUtility;

	@Autowired
	StringToNumberConversion stringToNumberConversion;

	@Autowired
	NewPolicyDao newPolicyDaoImpl;

	@Autowired
	SalesforceConnectorDao salesforceConnectorDaoImpl;
	final static Logger logger = Logger.getLogger(AuthorizationDaoImpl.class);

	private final static String SESSIONNAME = "NAVEENSESSIONID";
	private final static String FORMFREECREDCOOKIE = "formFreeCredCookie";
	private final static String SECRET = "27e799e85ebf430695cd915a29065805";
	private final static long IDLETIMEOUT = 600000;
	private final static long MAXTIMEOUT = 3600000;

	public Map<String, String> validateAndCreateSession(String cookie, String cookieType, boolean mfaValidationRequired,
			String mfaValidation) {
		Boolean isValid = false;
		Map<String, String> sessionObject = new HashMap<String, String>();
		sessionObject.put("validation", "failure");
		// Decrypt the formFreeCredCookie Generated by policy server
		String decryptedString = EncryptionDecryptionUtility.decrypt(cookie, SECRET);
		logger.info("Decrypted cookie String =" + decryptedString);
		String[] tokens = decryptedString.split("&");
		Map<String, String> keyValues = new LinkedHashMap<String, String>();
		for (int i = 0; i < tokens.length; i++) {
			String[] keyValue = tokens[i].split("=");
			keyValues.put(keyValue[0], keyValue[1]);
		}
		String createdTimeStampString = keyValues.get("createdTime");
		String userId = keyValues.get("sAMAccountName");
		sessionObject.put("userId", userId);
		// If MFA Enabled, validate SESSION for a particular attribute
		// "mfaValidation"
		if (mfaValidationRequired) {
			if (keyValues.containsKey("mfaValidation") && keyValues.get("mfaValidation").equalsIgnoreCase("success")) {
				sessionObject.put("mfaValidation", "success");
				logger.info("MFA validation is successful");
			} else {
				sessionObject.put("mfaValidation", "notdone");
			}
		}
		long timeStampFromCookie = stringToNumberConversion.getNumber(createdTimeStampString);
		long presentTimeStamp = System.currentTimeMillis();
		if (cookieType.equalsIgnoreCase(FORMFREECREDCOOKIE)) {
			// do some calculations to check the formFreecredcookie validity
			if (presentTimeStamp - timeStampFromCookie < 3000000) {
				isValid = true;
			}
		} else if (cookieType.equalsIgnoreCase(SESSIONNAME)) {
			// do some calculations to check the session validity
			long lastSessionTime = stringToNumberConversion.getNumber(keyValues.get("lastSessionTime"));
			if (presentTimeStamp - timeStampFromCookie < MAXTIMEOUT
					&& presentTimeStamp - lastSessionTime < IDLETIMEOUT) {
				isValid = true;
			}
		}

		if (isValid) {
			keyValues.put("lastSessionTime", "" + presentTimeStamp);
			keyValues.put("idleTimeOut", "" + IDLETIMEOUT);
			keyValues.put("maxTimeOut", "" + MAXTIMEOUT);
			if (mfaValidation.equalsIgnoreCase("success")) {
				keyValues.put("mfaValidation", "success");
			}
			String sessionID = EncryptionDecryptionUtility.encrypt(constructBaseString(keyValues), SECRET);
			logger.info("Generated Session ID " + sessionID);
			sessionObject.put("validation", "success");
			sessionObject.put("sessionID", sessionID);
		} else {
			logger.info("Invalid Cookie");
			logger.info("We Should return to Login Page");
		}

		return sessionObject;
	}

	public AuthorizationDecision isAuthorized(NewPolicy protectedPolicy, UserInfo userInfo, boolean mfaEnabled,
			String mfaValidation) {

		AuthorizationDecision authorizationDecision = new AuthorizationDecision();
		authorizationDecision.setAuthorized(false);
		String requiredGroups = protectedPolicy.getGroupName();
		if (!mfaEnabled) {
			if (requiredGroups.contains("ALL")) {
				logger.info("This resource can be accessed by all the employees");
				authorizationDecision.setAuthorized(true);
				;
			} else if (userInfo.getMemberOf().contains(requiredGroups)) {
				authorizationDecision.setAuthorized(true);
			}
		} else if (mfaEnabled && mfaValidation.equalsIgnoreCase("success")) {
			logger.info("MFA validation is successful and user is authorized to access target resource");
			authorizationDecision.setAuthorized(true);
			authorizationDecision.setMfaEnabled(true);
		} else if (mfaEnabled && userInfo.getMemberOf().contains(requiredGroups)){
			logger.info("MFA Enable application");
			authorizationDecision.setMfaEnabled(true);
		}
		return authorizationDecision;
	}

	public static String constructBaseString(Map keyValues) {
		String constructedString = "";
		StringBuilder sb = new StringBuilder();
		Set entry = keyValues.entrySet();
		Iterator iterator = entry.iterator();
		while (iterator.hasNext()) {
			Map.Entry<String, String> mapEntry = (Map.Entry<String, String>) iterator.next();
			String key = (String) mapEntry.getKey();
			String value = (String) mapEntry.getValue();
			sb.append(key).append("=").append(value).append("&");
		}
		constructedString = sb.substring(0, sb.length());
		logger.info("Constructed String " + constructedString);
		return constructedString;

	}

}
